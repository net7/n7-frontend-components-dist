import { Component, Input } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class InputTextareaComponent {
    onChange(inputPayload, value) {
        if (!this.emit)
            return;
        this.emit('change', { inputPayload, value });
    }
}
InputTextareaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: InputTextareaComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
InputTextareaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: InputTextareaComponent, selector: "n7-input-textarea", inputs: { data: "data", emit: "emit" }, ngImport: i0, template: "<div *ngIf=\"data as input\"\n     class=\"n7-input-textarea\">\n    <label *ngIf=\"input.label\"\n           class=\"n7-input-textarea__label\"\n           for=\"{{ input.id }}\"\n           [innerHTML]=\"input.label\">\n    </label>\n    <div class=\"n7-input-textarea__wrapper\"\n         [ngClass]=\"{\n            'has-icon': !!input.icon\n        }\">\n        <textarea id=\"{{ input.id }}\"\n                  class=\"n7-input-textarea__text\"\n                  [ngClass]=\"input.classes\"\n                  [attr.name]=\"input.name\"\n                  [value]=\"input.value || null\"\n                  [disabled]=\"input.disabled\"\n                  [required]=\"input.required\"\n                  [attr.placeholder]=\"input.placeholder\"\n                  [attr.autocomplete]=\"input.autocomplete\"\n                  [attr.autofocus]=\"input.autofocus\"\n                  [attr.maxlength]=\"input.maxlength\"\n                  [attr.minlength]=\"input.minlength\"\n                  [attr.rows]=\"input.rows\"\n                  [attr.cols]=\"input.cols\"\n                  (input)=\"onChange(input.inputPayload, $event.target.value)\"\n                  (keyup.enter)=\"onChange(input.enterPayload, $event.target.value)\">\n        </textarea>\n    </div>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: InputTextareaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'n7-input-textarea', template: "<div *ngIf=\"data as input\"\n     class=\"n7-input-textarea\">\n    <label *ngIf=\"input.label\"\n           class=\"n7-input-textarea__label\"\n           for=\"{{ input.id }}\"\n           [innerHTML]=\"input.label\">\n    </label>\n    <div class=\"n7-input-textarea__wrapper\"\n         [ngClass]=\"{\n            'has-icon': !!input.icon\n        }\">\n        <textarea id=\"{{ input.id }}\"\n                  class=\"n7-input-textarea__text\"\n                  [ngClass]=\"input.classes\"\n                  [attr.name]=\"input.name\"\n                  [value]=\"input.value || null\"\n                  [disabled]=\"input.disabled\"\n                  [required]=\"input.required\"\n                  [attr.placeholder]=\"input.placeholder\"\n                  [attr.autocomplete]=\"input.autocomplete\"\n                  [attr.autofocus]=\"input.autofocus\"\n                  [attr.maxlength]=\"input.maxlength\"\n                  [attr.minlength]=\"input.minlength\"\n                  [attr.rows]=\"input.rows\"\n                  [attr.cols]=\"input.cols\"\n                  (input)=\"onChange(input.inputPayload, $event.target.value)\"\n                  (keyup.enter)=\"onChange(input.enterPayload, $event.target.value)\">\n        </textarea>\n    </div>\n</div>\n" }]
        }], propDecorators: { data: [{
                type: Input
            }], emit: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtdGV4dGFyZWEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9kdi1jb21wb25lbnRzLWxpYi9zcmMvbGliL2NvbXBvbmVudHMvaW5wdXQtdGV4dGFyZWEvaW5wdXQtdGV4dGFyZWEudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9kdi1jb21wb25lbnRzLWxpYi9zcmMvbGliL2NvbXBvbmVudHMvaW5wdXQtdGV4dGFyZWEvaW5wdXQtdGV4dGFyZWEuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBa0VqRCxNQUFNLE9BQU8sc0JBQXNCO0lBS2pDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsS0FBTTtRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQzs7bUhBUlUsc0JBQXNCO3VHQUF0QixzQkFBc0IsaUdDbEVuQyx5d0NBOEJBOzJGRG9DYSxzQkFBc0I7a0JBSmxDLFNBQVM7K0JBQ0UsbUJBQW1COzhCQUlwQixJQUFJO3NCQUFaLEtBQUs7Z0JBRUcsSUFBSTtzQkFBWixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT25PZmYgfSBmcm9tICcuLi8uLi9zaGFyZWQtaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCB0eXBlIElucHV0VGV4dGFyZWFEYXRhID0ge1xuICAvKiogVW5pcXVlIElEIGZvciB0aGUgdGV4dCBpbnB1dCBlbGVtZW50ICovXG4gIGlkOiBzdHJpbmc7XG4gIC8qKiBBIGhpbnQgdG8gdGhlIHVzZXIgb2Ygd2hhdCBjYW4gYmUgZW50ZXJlZCBpbiB0aGUgY29udHJvbC4gKi9cbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIC8qKiBEZWZhdWx0IHZhbHVlIG9mIHRoZSB0ZXh0YXJlYSAqL1xuICB2YWx1ZT86IHN0cmluZyB8IG51bWJlciB8IG51bGw7XG4gIC8qKiBMYWJlbCBmb3IgdGhlIHRleHRhcmVhICovXG4gIGxhYmVsPzogc3RyaW5nO1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhlIGNvbnRyb2wuXG4gICAqIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjb250cm9sIGluaGVyaXRzIGl0cyBzZXR0aW5nXG4gICAqIGZyb20gdGhlIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICovXG4gIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCBjYW4gYmUgYXV0b21hdGljYWxseSBjb21wbGV0ZWQgYnkgdGhlIGJyb3dzZXIuICovXG4gIGF1dG9jb21wbGV0ZT86IE9uT2ZmO1xuICAvKipcbiAgICogTGV0cyB5b3Ugc3BlY2lmeSB0aGF0IGEgZm9ybSBjb250cm9sIHNob3VsZCBoYXZlIGlucHV0IGZvY3VzIHdoZW4gdGhlIHBhZ2UgbG9hZHMuXG4gICAqIE9ubHkgb25lIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50IGluIGEgZG9jdW1lbnQgY2FuIGhhdmUgdGhpcyBhdHRyaWJ1dGUgc3BlY2lmaWVkLlxuICAgKi9cbiAgYXV0b2ZvY3VzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIChVVEYtMTYgY29kZSB1bml0cykgdGhhdCB0aGUgdXNlciBjYW4gZW50ZXIuXG4gICAqIElmIHRoaXMgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkLCB0aGUgdXNlciBjYW4gZW50ZXIgYW4gdW5saW1pdGVkIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgbWF4bGVuZ3RoPzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgKFVURi0xNiBjb2RlIHVuaXRzKSByZXF1aXJlZCB0aGF0IHRoZSB1c2VyIHNob3VsZCBlbnRlci5cbiAgICovXG4gIG1pbmxlbmd0aD86IG51bWJlcjtcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLiAqL1xuICBuYW1lPzogc3RyaW5nO1xuICAvKiogU3BlY2lmaWVzIHRoYXQgdGhlIHVzZXIgbXVzdCBmaWxsIGluIGEgdmFsdWUgYmVmb3JlIHN1Ym1pdHRpbmcgYSBmb3JtLiAqL1xuICByZXF1aXJlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHZpc2libGUgdGV4dCBsaW5lcyBmb3IgdGhlIGNvbnRyb2wuXG4gICAqIElmIGl0IGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAqIEBkZWZhdWx0VmFsdWUgMlxuICAgKi9cbiAgcm93cz86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSB2aXNpYmxlIHdpZHRoIG9mIHRoZSB0ZXh0IGNvbnRyb2wsIGluIGF2ZXJhZ2UgY2hhcmFjdGVyIHdpZHRocy5cbiAgICogSWYgaXQgaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAgICogQGRlZmF1bHRWYWx1ZSAyMFxuICAgKi9cbiAgY29scz86IG51bWJlcjtcbiAgLyoqIFBheWxvYWQgdGhhdCBpcyBzZW50IHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgdmFsdWUgKi9cbiAgaW5wdXRQYXlsb2FkPzogYW55O1xuICAvKiogUGF5bG9hZCB0aGF0IGlzIHNlbnQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBcIkVudGVyXCIga2V5ICovXG4gIGVudGVyUGF5bG9hZD86IGFueTtcbiAgLyoqIFBheWxvYWQgdGhhdCBpcyBzZW50IHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBpY29uICovXG4gIGljb25QYXlsb2FkPzogYW55O1xuICAvKiogQWRkaXRpb25hbCBIVE1MIENsYXNzZXMgKi9cbiAgY2xhc3Nlcz86IGFueTtcbiAgLyoqIEFkZGl0aW9uYWwgZGF0YSBmb3IgdGhlIGNvbXBvbmVudCdzIGxvZ2ljICovXG4gIF9tZXRhPzogYW55O1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduNy1pbnB1dC10ZXh0YXJlYScsXG4gIHRlbXBsYXRlVXJsOiAnLi9pbnB1dC10ZXh0YXJlYS5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJbnB1dFRleHRhcmVhQ29tcG9uZW50IHtcbiAgQElucHV0KCkgZGF0YTogSW5wdXRUZXh0YXJlYURhdGE7XG5cbiAgQElucHV0KCkgZW1pdDogKHR5cGU6IHN0cmluZywgcGF5bG9hZD86IHVua25vd24pID0+IHZvaWQ7XG5cbiAgb25DaGFuZ2UoaW5wdXRQYXlsb2FkLCB2YWx1ZT8pIHtcbiAgICBpZiAoIXRoaXMuZW1pdCkgcmV0dXJuO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgeyBpbnB1dFBheWxvYWQsIHZhbHVlIH0pO1xuICB9XG59XG4iLCI8ZGl2ICpuZ0lmPVwiZGF0YSBhcyBpbnB1dFwiXG4gICAgIGNsYXNzPVwibjctaW5wdXQtdGV4dGFyZWFcIj5cbiAgICA8bGFiZWwgKm5nSWY9XCJpbnB1dC5sYWJlbFwiXG4gICAgICAgICAgIGNsYXNzPVwibjctaW5wdXQtdGV4dGFyZWFfX2xhYmVsXCJcbiAgICAgICAgICAgZm9yPVwie3sgaW5wdXQuaWQgfX1cIlxuICAgICAgICAgICBbaW5uZXJIVE1MXT1cImlucHV0LmxhYmVsXCI+XG4gICAgPC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwibjctaW5wdXQtdGV4dGFyZWFfX3dyYXBwZXJcIlxuICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgJ2hhcy1pY29uJzogISFpbnB1dC5pY29uXG4gICAgICAgIH1cIj5cbiAgICAgICAgPHRleHRhcmVhIGlkPVwie3sgaW5wdXQuaWQgfX1cIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJuNy1pbnB1dC10ZXh0YXJlYV9fdGV4dFwiXG4gICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJpbnB1dC5jbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwiaW5wdXQubmFtZVwiXG4gICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiaW5wdXQudmFsdWUgfHwgbnVsbFwiXG4gICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiaW5wdXQuZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgW3JlcXVpcmVkXT1cImlucHV0LnJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLnBsYWNlaG9sZGVyXT1cImlucHV0LnBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLmF1dG9jb21wbGV0ZV09XCJpbnB1dC5hdXRvY29tcGxldGVcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2ZvY3VzXT1cImlucHV0LmF1dG9mb2N1c1wiXG4gICAgICAgICAgICAgICAgICBbYXR0ci5tYXhsZW5ndGhdPVwiaW5wdXQubWF4bGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLm1pbmxlbmd0aF09XCJpbnB1dC5taW5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIucm93c109XCJpbnB1dC5yb3dzXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLmNvbHNdPVwiaW5wdXQuY29sc1wiXG4gICAgICAgICAgICAgICAgICAoaW5wdXQpPVwib25DaGFuZ2UoaW5wdXQuaW5wdXRQYXlsb2FkLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICAgICAgICAgICAgICAoa2V5dXAuZW50ZXIpPVwib25DaGFuZ2UoaW5wdXQuZW50ZXJQYXlsb2FkLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuICAgICAgICA8L3RleHRhcmVhPlxuICAgIDwvZGl2PlxuPC9kaXY+XG4iXX0=