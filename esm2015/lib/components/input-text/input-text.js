//---------------------------
// INPUT-TEXT.ts
//---------------------------
import { __decorate, __metadata } from "tslib";
import { Component, Input } from '@angular/core';
let InputTextComponent = class InputTextComponent {
    onChange(inputPayload, value) {
        if (!this.emit)
            return;
        this.emit('change', { inputPayload, value });
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputTextComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputTextComponent.prototype, "emit", void 0);
InputTextComponent = __decorate([
    Component({
        selector: 'n7-input-text',
        template: "<div *ngIf=\"data as input\"\r\n     class=\"n7-input-text\">\r\n    <label *ngIf=\"input.label\"\r\n        class=\"n7-input-text__label\"\r\n        for=\"{{ input.id }}\">\r\n        {{ input.label }}\r\n    </label>\r\n    <div class=\"n7-input-text__wrapper\"\r\n        [ngClass]=\"{\r\n            'has-icon': !!input.icon\r\n        }\">\r\n        <input id=\"{{ input.id }}\"\r\n            class=\"n7-input-text__text {{input.classes || ''}}\"\r\n            placeholder=\"{{input.placeholder || ''}}\"\r\n            [type]=\"input.type ? input.type : 'text'\"\r\n            [value]=\"input.value || null\"\r\n            [disabled]=\"input.disabled\"\r\n            [min]=\"input.type === 'number' && (input.min || input.min === 0) ? input.min : ''\"\r\n            [max]=\"input.type === 'number' && (input.max || input.max === 0) ? input.max : ''\"\r\n            (input)=\"onChange(input.inputPayload, $event.target.value)\"\r\n            (keyup.enter)=\"onChange(input.enterPayload, $event.target.value)\">\r\n        <span *ngIf=\"input.icon\"\r\n            class=\"n7-input-text__icon {{input.icon || ''}}\"\r\n            (click)=\"onChange(input.iconPayload)\">\r\n        </span>\r\n    </div>\r\n</div>\r\n"
    })
], InputTextComponent);
export { InputTextComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtdGV4dC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuNy1mcm9udGVuZC9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvaW5wdXQtdGV4dC9pbnB1dC10ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QjtBQUM3QixnQkFBZ0I7QUFDaEIsNkJBQTZCOztBQUU3QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQWdGakQsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFLN0IsUUFBUSxDQUFDLFlBQVksRUFBRSxLQUFNO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSTtZQUFFLE9BQU87UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUMvQyxDQUFDO0NBQ0YsQ0FBQTtBQVJVO0lBQVIsS0FBSyxFQUFFOztnREFBcUI7QUFFcEI7SUFBUixLQUFLLEVBQUU7O2dEQUFXO0FBSFIsa0JBQWtCO0lBSjlCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxlQUFlO1FBQ3pCLDR0Q0FBZ0M7S0FDakMsQ0FBQztHQUNXLGtCQUFrQixDQVM5QjtTQVRZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIElOUFVULVRFWFQudHNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZm9yIElucHV0VGV4dERhdGFcclxuICpcclxuICogQHByb3BlcnR5IGlkIChyZXF1aXJlZClcclxuICogQHByb3BlcnR5IHBsYWNlaG9sZGVyIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IHZhbHVlIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IGxhYmVsIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IGRpc2FibGVkIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IGljb24gKG9wdGlvbmFsKVxyXG4gKiBAcHJvcGVydHkgaW5wdXRQYXlsb2FkIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IGVudGVyUGF5bG9hZCAob3B0aW9uYWwpXHJcbiAqIEBwcm9wZXJ0eSBpY29uUGF5bG9hZCAob3B0aW9uYWwpXHJcbiAqIEBwcm9wZXJ0eSBjbGFzc2VzIChvcHRpb25hbClcclxuICogQHByb3BlcnR5IF9tZXRhIChvcHRpb25hbClcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRUZXh0RGF0YSB7XHJcbiAgLyoqXHJcbiAgICogVW5pcXVlIElEIGZvciB0aGUgdGV4dCBpbnB1dCBlbGVtZW50XHJcbiAgICovXHJcbiAgaWQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBJbnB1dCB0eXBlXHJcbiAgICovXHJcbiAgdHlwZT86ICd0ZXh0JyB8ICdudW1iZXInO1xyXG4gIC8qKlxyXG4gICAqIFBsYWNlaG9sZGVyIHRleHQgaW5zaWRlIHRoZSBpbnB1dCBib3hcclxuICAgKi9cclxuICBwbGFjZWhvbGRlcj86IHN0cmluZztcclxuICAvKipcclxuICAgKiBEZWZhdWx0IHZhbHVlIG9mIHRoZSBpbnB1dCBib3hcclxuICAgKi9cclxuICB2YWx1ZT86IHN0cmluZyB8IG51bWJlciB8IG51bGw7XHJcbiAgLyoqXHJcbiAgICogTGFiZWwgZm9yIHRoZSBpbnB1dCBib3hcclxuICAgKi9cclxuICBsYWJlbD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSBpbnB1dCdzIHZhbHVlXHJcbiAgICovXHJcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIE9wdGlvbmFsIGljb24gdG8gcmVuZGVyIGluc2lkZSB0aGUgaW5wdXQgYm94IChlZy4gbjctaWNvbi1zZWFyY2gpXHJcbiAgICovXHJcbiAgaWNvbj86IHN0cmluZztcclxuICAvKipcclxuICAgKiBQYXlsb2FkIHRoYXQgaXMgc2VudCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZhbHVlXHJcbiAgICovXHJcbiAgaW5wdXRQYXlsb2FkPzogYW55O1xyXG4gIC8qKlxyXG4gICAqIFBheWxvYWQgdGhhdCBpcyBzZW50IHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgXCJFbnRlclwiIGtleVxyXG4gICAqL1xyXG4gIGVudGVyUGF5bG9hZD86IGFueTtcclxuICAvKipcclxuICAgKiBQYXlsb2FkIHRoYXQgaXMgc2VudCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgaWNvblxyXG4gICAqL1xyXG4gIGljb25QYXlsb2FkPzogYW55O1xyXG4gIC8qKlxyXG4gICAqIElucHV0IG1pbmltdW4gYWxsb3dlZCB2YWx1ZSAob25seSBmb3IgdHlwZT1udW1iZXIpXHJcbiAgICovXHJcbiAgbWluPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIElucHV0IG1heGltdW4gYWxsb3dlZCB2YWx1ZSAob25seSBmb3IgdHlwZT1udW1iZXIpXHJcbiAgICovXHJcbiAgbWF4PzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIEFkZGl0aW9uYWwgSFRNTCBDbGFzc2VzXHJcbiAgICovXHJcbiAgY2xhc3Nlcz86IGFueTtcclxuICAvKipcclxuICAgKiBBZGRpdGlvbmFsIGRhdGEgZm9yIHRoZSBjb21wb25lbnQncyBsb2dpY1xyXG4gICAqL1xyXG4gIF9tZXRhPzogYW55O1xyXG59XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ243LWlucHV0LXRleHQnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9pbnB1dC10ZXh0Lmh0bWwnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJbnB1dFRleHRDb21wb25lbnQge1xyXG4gIEBJbnB1dCgpIGRhdGE6IElucHV0VGV4dERhdGE7XHJcblxyXG4gIEBJbnB1dCgpIGVtaXQ6IGFueTtcclxuXHJcbiAgb25DaGFuZ2UoaW5wdXRQYXlsb2FkLCB2YWx1ZT8pIHtcclxuICAgIGlmICghdGhpcy5lbWl0KSByZXR1cm47XHJcbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHsgaW5wdXRQYXlsb2FkLCB2YWx1ZSB9KTtcclxuICB9XHJcbn1cclxuIl19